{
  "title": "1.1 文件读写：C文件读写函数介绍",
  "cells": [
    {
      "type": "text",
      "data": "<div style=\"word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; white-space: normal;\"><div><table border=\"0\" style=\"color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);width:845px;\"><tr><td style=\"width:99.52662721893492%;\"><div><p><span style=\"font-size: medium;\"><strong>1.fopen()</strong></span></p><p><strong><br/></strong><span style=\"font-size: medium;\">　　fopen的原型是：FILE *fopen(const char *filename,const char *mode)，fopen实现三个功能：为使用而打开一个流，把一个文件和此流相连接，给此流返回一个FILR指针。<br/><br/>\n　　参数filename指向要打开的文件名，mode表示打开状态的字符串，其取值如下：&nbsp;<br/><br/>\n　　字符串 含义&nbsp;<br/><br/>\n　　&quot;r&quot; 以只读方式打开文件&nbsp;<br/><br/>\n　　&quot;w&quot; 以只写方式打开文件&nbsp;<br/><br/>\n　　&quot;a&quot; 以追加方式打开文件&nbsp;<br/><br/>\n　　&quot;r+&quot; 以读/写方式打开文件，如无文件出错&nbsp;<br/><br/>\n　　&quot;w+&quot; 以读/写方式打开文件，如无文件生成新文件&nbsp;<br/><br/>\n　　一个文件可以以文本模式或二进制模式打开，这两种的区别是：在文本模式中回车被当成一个字符’/n’，而二进制模式认为它是两个字符0x0D,0x0A;如果在文件中读到0x1B，文本模式会认为这是文件结束符，也就是二进制模型不会对文件进行处理，而文本方式会按一定的方式对数据作相应的转换。&nbsp;<br/><br/>\n　　系统默认的是以文本模式打开，可以修改全部变量_fmode的值来修改这个设置，例如_fmode=O_TEXT;就设置默认打开方式为文本模式;而_fmode=O_BINARY;则设置默认打开方式是二进制模式。&nbsp;<br/><br/>\n　　我们也可以在模式字符串中指定打开的模式，如&quot;rb&quot;表示以二进制模式打开只读文件，&quot;w+t&quot;或&quot;wt+&quot;表示以文本模式打开读/写文件。&nbsp;<br/><br/>\n　　此函数返回一个FILE指针，所以申明一个FILE指针后不用初始化，而是用fopen()来返回一个指针并与一个特定的文件相连，如果成败，返回NULL.<br/>\n　　例:&nbsp;<br/>\n　　 以下是引用片段：&nbsp;<br/>\nFILE *fp;&nbsp;<br/>\n　　if(fp=fopen(&quot;123.456&quot;,&quot;wb&quot;))&nbsp;<br/>\n　　puts(&quot;打开文件成功&quot;);&nbsp;<br/>\n　　else&nbsp;<br/>\n　　puts(&quot;打开文件成败&quot;);</span></p><p><span style=\"font-size: medium;\"><br/><strong>2.fclose()</strong></span></p><p><span style=\"font-size: medium;\"><br/>\n　　fclose()的功能就是关闭用fopen()打开的文件，其原型是：int fclose(FILE *fp);如果成功，返回0,失败返回EOF。&nbsp;<br/><br/>\n　　在程序结束时一定要记得关闭打开的文件，不然可能会造成数据丢失的情况，我以前就经常犯这样的错误。<br/><br/>\n　　例：fclose(fp);&nbsp;<br/><br/><strong>3.fputc()</strong></span></p><p><span style=\"font-size: medium;\"><br/>\n　　向流写一个字符，原型是int fputc(int&nbsp;<strong>c</strong>, FILE *stream); 成功返回这个字符,失败返回EOF。&nbsp;<br/><br/>\n　　例：fputc(’X’,fp);&nbsp;<br/><br/><strong>4.fgetc()&nbsp;<br/></strong>　　从流中读一个字符，原型是int fputc(FILE *stream); 成功返回这个字符,失败返回EOF。&nbsp;<br/><br/>\n　　例：char ch1=fgetc(fp);&nbsp;<br/><br/><strong>5. fseek()</strong></span></p><p><span style=\"font-size: medium;\"><strong><br/></strong>　　此函数一般用于二进制模式打开的文件中，功能是定位到流中指定的位置，原型是int fseek(FILE *stream, long offset, int whence);如果成功返回0，参数offset是移动的字符数，whence是移动的基准，取值是：&nbsp;<br/><br/>\n　　符号常量 值 基准位置&nbsp;<br/><br/>\n　　SEEK_SET 0 文件开头&nbsp;<br/><br/>\n　　SEEK_CUR 1 当前读写的位置&nbsp;<br/><br/>\n　　SEEK_END 2 文件尾部&nbsp;<br/><br/>\n　　例：fseek(fp,1234L,SEEK_CUR);//把读写位置从当前位置向后移动1234字节(L后缀表示长整数)&nbsp;<br/><br/>\n　　fseek(fp,0L,2);//把读写位置移动到文件尾</span></p><p><span style=\"font-size: medium;\"><strong>6.fputs()</strong>&nbsp;<br/><br/>\n　　写一个字符串到流中，原型int fputs(const char *s, FILE *stream);&nbsp;<br/><br/>\n　　例：fputs(&quot;I Love You&quot;,fp);&nbsp;<br/><br/><strong>7.fgets()</strong></span></p><p><span style=\"font-size: medium;\"><strong><br/></strong>　　从流中读一行或指定个字符，原型是char *fgets(char *s, int n, FILE *stream); 从流中读取n-1个字符，除非读完一行，参数s是来接收字符串，如果成功则返回s的指针，否则返回NULL。&nbsp;<br/><br/>\n　　例：如果一个文件的当前位置的文本如下：&nbsp;<br/>\n　　Love ,I Have&nbsp;<br/><br/>\n　　But ……..&nbsp;<br/><br/>\n　　如果用&nbsp;<br/><br/>\n　　fgets(str1,4,file1);&nbsp;<br/><br/>\n　　则执行后str1=&quot;Lov&quot;，读取了4-1=3个字符，而如果用&nbsp;<br/><br/>\n　　fgets(str1,23,file1);&nbsp;<br/><br/>\n　　则执行str=&quot;Love ,I Have&quot;，读取了一行(不包括行尾的’/n’)。&nbsp;<br/><br/><strong>8.fprintf()</strong></span></p><p><span style=\"font-size: medium;\"><br/>\n　　按格式输入到流，其原型是int fprintf(FILE *stream, const char *format[, argument, …]);其用法和printf()相同，不过不是写到控制台，而是写到流罢了。&nbsp;<br/><br/>\n　　例：fprintf(fp,&quot;%2d%s&quot;,4,&quot;Hahaha&quot;);&nbsp;<br/><br/><strong>9.fscanf()</strong></span></p><p><span style=\"font-size: medium;\"><br/>\n　　从流中按格式读取，其原型是int fscanf(FILE *stream, const char *format[, address, …]);其用法和scanf()相同，不过不是从控制台读取，而是从流读取罢了。&nbsp;<br/><br/>\n　　例：fscanf(fp,&quot;%d%d&quot; ,&amp;x,&amp;y);&nbsp;<br/><br/><strong>10.feof()</strong></span></p><p><span style=\"font-size: medium;\"><br/>\n　　检测是否已到文件尾，是返回真，否则返回0，其原型是int feof(FILE *stream);&nbsp;<br/><br/>\n　　例：if(feof(fp))printf(&quot;已到文件尾&quot;);&nbsp;<br/><br/><strong>11.ferror()</strong></span></p><p><span style=\"font-size: medium;\"><strong><br/></strong>　　原型是int ferror(FILE *stream);返回流最近的错误代码，可用clearerr()来清除它，clearerr()的原型是void clearerr(FILE *stream);&nbsp;<br/><br/>\n　　例：printf(&quot;%d&quot;,ferror(fp));&nbsp;<br/><br/><strong>12.rewind()</strong></span></p><p><span style=\"font-size: medium;\"><br/>\n　　把当前的读写位置回到文件开始，原型是void rewind(FILE *stream);其实本函数相当于fseek(fp,0L,SEEK_SET);&nbsp;<br/><br/>\n　　例：rewind(fp);&nbsp;<br/><br/><strong>13.remove()</strong></span></p><p><span style=\"font-size: medium;\"><br/>\n　　删除文件，原型是int remove(const char *filename); 参数就是要删除的文件名，成功返回0。&nbsp;<br/><br/>\n　　例：remove(&quot;<strong>c</strong>://io.sys&quot;);&nbsp;<br/><br/><strong>14.fread()</strong></span></p><p><span style=\"font-size: medium;\"><br/>\n　　从流中读指定个数的字符，原型是size_t fread(void *ptr, size_t size, size_t n, FILE *stream);参数ptr是保存读取的数据，void*的指针可用任何类型的指针来替换，如char*、int *等等来替换;size是每块的字节数;n是读取的块数，如果成功，返回实际读取的块数(不是字节数)，本函数一般用于二进制模式打开的文件中。&nbsp;<br/><br/>\n　　例：&nbsp;<br/>\n　　 以下是引用片段：&nbsp;<br/>\nchar x[4230];&nbsp;<br/>\n　　FILE *file1=fopen(&quot;<strong>c</strong>://msdos.sys&quot;,&quot;r&quot;);&nbsp;<br/>\n　　fread(x,200,12 ,file1);//共读取200*12=2400个字节&nbsp;<br/><br/><strong>15.fwrite()</strong></span></p><p><span style=\"font-size: medium;\"><strong><br/></strong>　　与fread对应，向流中写指定的数据，原型是size_t fwrite(const void *ptr, size_t size, size_t n, FILE *stream);参数ptr是要写入的数据指针，void*的指针可用任何类型的指针来替换，如char*、int *等等来替换;size是每块的字节数;n是要写的块数，如果成功，返回实际写入的块数(不是字节数)，本函数一般用于二进制模式打开的文件中。<br/><br/>\n　　例：&nbsp;<br/>\n　　 以下是引用片段：&nbsp;<br/>\n　　char x[]=&quot;I Love You&quot;;&nbsp;<br/>\n　　fwire(x, 6,12,fp);//写入6*12=72字节&nbsp;<br/>\n　　将把&quot;I Love&quot;写到流fp中12次，共72字节&nbsp;<br/><br/><strong>16.tmpfile()</strong></span></p><p><span style=\"font-size: medium;\"><br/>\n　　其原型是FILE *tmpfile(void); 生成一个临时文件，以&quot;w+b&quot;的模式打开，并返回这个临时流的指针，如果失败返回NULL。在程序结束时，这个文件会被自动删除。&nbsp;<br/><br/>\n　　例：FILE *fp=tmpfile();&nbsp;<br/><br/><strong>17.tmpnam();</strong></span></p><p><span style=\"font-size: medium;\"><br/>\n　　其原型为char *tmpnam(char *s); 生成一个唯一的文件名，其实tmpfile()就调用了此函数，参数s用来保存得到的文件名，并返回这个指针，如果失败，返回NULL。&nbsp;<br/><br/>\n　　例：tmpnam(str1);</span></p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p><span style=\"font-size: medium;\">1.&nbsp;&nbsp;&nbsp;&nbsp;首先要理解几个概念：&nbsp;<br/><br/>\n文件：&nbsp;按一定规则存储在磁盘上的数据集合。&nbsp;<br/><br/>\n文件名：&nbsp;能唯一标识某个磁盘文件的字符串。形式：&nbsp;盘符：/&nbsp;路径&nbsp;/&nbsp;文件名.扩展名&nbsp;<br/><br/>\n文本文件:：&nbsp;数据以其数字字符的ASCII码形式、一个字节一个字节地存储在磁盘上。&nbsp;<br/><br/>\n二进制文件：数据以二进制形式在存储在磁盘上。&nbsp;<br/><br/>\n设备文件：输入/输出设备&nbsp;<br/><br/>\n标准输入文件：键盘&nbsp;<br/><br/>\n标准输出文件/标准错误输出文件：显示器&nbsp;<br/><br/>\n文件型指针：C语言是通过名为FILE的结构型指针来管理文件读写的。FILE&nbsp;*&lt;变量名&gt;&nbsp;<br/><br/>\n文件的打开和关闭&nbsp;：文件操作先建立文件与文件指针之间的关系，接着进行文件的读与写。建立文件与文件指针之间的联系的过程是文件的打开。终止这种联系就是文件的关闭。&nbsp;<br/><br/>\nFILE结构：定义在〈stdio.h〉中。形式如下：&nbsp;<br/><br/>\ntypedef&nbsp;struct&nbsp;<br/><br/>\n{&nbsp;<br/><br/>\nint&nbsp;&nbsp;_fd;&nbsp;&nbsp;&nbsp;/*文件代号*/&nbsp;<br/><br/>\nint&nbsp;&nbsp;_cleft;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;文件缓冲区所剩字节数*/&nbsp;<br/><br/>\nint&nbsp;&nbsp;_mode;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;文件使用模式*/&nbsp;<br/><br/>\nchar&nbsp;&nbsp;*nextc;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;下一个等待处理的字节地址，&nbsp;即文件内部指针*/&nbsp;<br/><br/>\nchar&nbsp;&nbsp;*buff;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;文件缓冲区首地址&nbsp;&nbsp;*/&nbsp;<br/><br/>\n}FILE;&nbsp;<br/><br/>\n2.&nbsp;主要操作函数用相应的使用&nbsp;<br/><br/>\n1)&nbsp;文件的打开与关闭:&nbsp;&nbsp;<br/><br/>\n#include&nbsp;&lt;stdio.h&gt;&nbsp;<br/><br/>\nFILE&nbsp;*fp;&nbsp;<br/><br/>\nfp&nbsp;=&nbsp;fopen(char*&nbsp;filename,&nbsp;&nbsp;char*&nbsp;&nbsp;made);&nbsp;<br/><br/>\nif(fp&nbsp;==&nbsp;NULL)&nbsp;<br/><br/>\n{&nbsp;<br/><br/>\nexit(0);&nbsp;<br/><br/>\n}&nbsp;<br/><br/>\nfclose(fp)&nbsp;<br/><br/>\nmode和种类有:&nbsp;<br/><br/>\nr&nbsp;:&nbsp;打开一个文本文件,供读取数据,&nbsp;文件不存在,则返回NULL&nbsp;<br/><br/>\nw&nbsp;:&nbsp;建立一个供写入的文本文件.&nbsp;废弃原有内容&nbsp;<br/><br/>\na:&nbsp;打开或建立一个把数据追加到文件尾的文本文件&nbsp;<br/><br/>\nr+:&nbsp;更新数据&nbsp;<br/><br/>\nw+&nbsp;:&nbsp;更新数据,废弃原有内容&nbsp;<br/><br/>\na+&nbsp;:&nbsp;更新数据,&nbsp;写入的数据追加到文件尾.&nbsp;<br/><br/>\n二进制在后面加&quot;b&quot;&nbsp;<br/><br/>\n标准输入/输出文件的文件型指针:&nbsp;&nbsp;stdin,&nbsp;stdout,&nbsp;stderr&nbsp;<br/><br/>\n2)&nbsp;&nbsp;&nbsp;文件的读与写:&nbsp;<br/><br/>\n把一个字符写入文件,&nbsp;或从文件中读取一个字符:&nbsp;&nbsp;文件内部指针自动移向下一位可读写的位置&nbsp;<br/><br/>\nint&nbsp;fputc(char&nbsp;ch,&nbsp;FILE&nbsp;*fp);&nbsp;<br/><br/>\nint&nbsp;fgetc(&nbsp;FILE&nbsp;*fp)&nbsp;<br/><br/>\n把一行数据写入文件,&nbsp;或读取一行数据:&nbsp;<br/><br/>\nchar&nbsp;*&nbsp;fputs(char&nbsp;*str,&nbsp;FILE&nbsp;*fp)&nbsp;<br/><br/>\nchar&nbsp;*&nbsp;fgets(char&nbsp;*str,&nbsp;int&nbsp;n,&nbsp;FILE&nbsp;*fp)&nbsp;;&nbsp;//&nbsp;读取N-1&nbsp;个字符,第N个字符补&apos;/0&apos;&nbsp;<br/><br/>\n把指定字节数的若干数据写入文件,&nbsp;或读出文件.&nbsp;<br/><br/>\nint&nbsp;fwrite(char&nbsp;*&nbsp;buf,&nbsp;unsigned&nbsp;size,&nbsp;unsigned&nbsp;n,&nbsp;FILE&nbsp;*fp);&nbsp;size&nbsp;每个数据的字节数,&nbsp;&nbsp;n&nbsp;个数据.&nbsp;<br/><br/>\nint&nbsp;fread(char&nbsp;*buf,&nbsp;unsigned&nbsp;size,&nbsp;unsigned&nbsp;n,&nbsp;FILE&nbsp;*fp);&nbsp;<br/><br/>\n把指定格式的数据写入文件,&nbsp;或读取指定格式的数据&nbsp;<br/><br/>\nint&nbsp;fprintf(FILE&nbsp;*fp,&nbsp;char&nbsp;*format,&nbsp;e1,e2,......en);&nbsp;<br/><br/>\nint&nbsp;fscanf(FILE&nbsp;*fp,&nbsp;char&nbsp;*format,&nbsp;e1,e2,......en);&nbsp;<br/><br/>\n&nbsp;&nbsp;<br/><br/>\n3)&nbsp;文件位置的确定与指针管理.&nbsp;<br/><br/>\n&nbsp;&nbsp;<br/><br/>\n文件尾的测试:&nbsp;&nbsp;int&nbsp;feof(FILE&nbsp;*fp);&nbsp;//当前已到达文件尾返回非0,&nbsp;否则返回0&nbsp;<br/><br/>\n不同的计算机系统以不同的键盘组合键形成文件的结束符.&nbsp;IBM&nbsp;PC及其兼容机是&lt;ctrl&gt;&nbsp;+&nbsp;z&nbsp;<br/><br/>\n&nbsp;&nbsp;<br/><br/>\n把文件内部指针重新定位到文件的起始位置&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;rewind(FILE&nbsp;*fp);&nbsp;<br/><br/>\n&nbsp;&nbsp;<br/><br/>\n把文件内部指针定位到指定的位置:&nbsp;&nbsp;&nbsp;int&nbsp;fseek(FILE&nbsp;*fp,&nbsp;long&nbsp;offset,&nbsp;int&nbsp;from);&nbsp;&nbsp;<br/><br/>\nfrom&nbsp;是定位的起始点.&nbsp;<br/><br/>\nSEEK_SET&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;从文件头开始&nbsp;<br/><br/>\nSEEK_CUR&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;从文件内部指针当前位置开始&nbsp;<br/><br/>\nSEEK_END&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;从文件尾开始&nbsp;<br/><br/>\noffset&nbsp;是以From&nbsp;为起始点的依稀字节数,大于0表示向文件尾方向,&nbsp;0&nbsp;不移动,&nbsp;&nbsp;<br/><br/>\n&nbsp;&nbsp;<br/><br/>\n文件操作出错测式&nbsp;&nbsp;&nbsp;int&nbsp;ferror(FILE&nbsp;*fp);&nbsp;&nbsp;<br/><br/>\n用于对由FP指向的文件最近一次操作进行正确性测试.&nbsp;出错返回非0,还没返回0&nbsp;<br/><br/>\n&nbsp;&nbsp;<br/><br/>\n4)&nbsp;&nbsp;文件的删除&nbsp;<br/><br/>\nint&nbsp;remove(char&nbsp;*&nbsp;filename);&nbsp;<br/><br/>\n&nbsp;&nbsp;<br/><br/>\n&nbsp;&nbsp;3.&nbsp;&nbsp;一些以前我没想到的知识点.&nbsp;<br/><br/>\nchar&nbsp;ch;&nbsp;<br/><br/>\nch&nbsp;=&nbsp;getchar&nbsp;()&nbsp;&nbsp;功能等价于&nbsp;ch&nbsp;=&nbsp;fgetc(stdin)&nbsp;&nbsp;功能等价于&nbsp;scanf(&quot;%c&quot;,ch)&nbsp;&nbsp;&nbsp;功能等价于&nbsp;fscanf(stdin,&nbsp;&quot;%c&quot;,ch)&nbsp;<br/><br/>\nputchar(ch)&nbsp;&nbsp;功能等价于&nbsp;printf(&quot;%c&quot;,ch)&nbsp;&nbsp;&nbsp;功能等价于&nbsp;fputc(stdout)&nbsp;&nbsp;&nbsp;功能等价于&nbsp;fprintf(stdout,&nbsp;&quot;%c&quot;,&nbsp;ch)&nbsp;</span></p></div></td></tr></table></div></div>"
    }
  ]
}